# 数据的表达
为了能够在计算机中表达一个确定的事物或概念，我们需要一段具有特定含义的二进制数据。我们要规定数据的读写方式，让它接近、模拟、还原我们想要表达的概念，直到我们能够在思维上认定这段数据代表了这个概念，在数据上产生的结论也能还原到真实世界中。

现实的概念表达为数据，最简单也是最直观的例子是数，但这个例子中包含了关于数据的常见考虑，从而能够作为用数据表达概念的良好示范。

整数转换成二进制本身是容易的，你可以将转换的结果作为整数的计算机表示。在此基础上，小数也可以通过科学记数法来记录：用表示整数的方式分别记录有效数字和幂次。然而我们知道，一段数据的长度，在计算机中终究是有限的，能够表达的信息也是有限的，这意味着并不是所有的数都能在计算机中表达。于是，不管你设计怎样的数据表示方式，都是对真实概念的一种近似。数据表达概念的常见思考，就集中在考虑数据有何种需要、从而决定近似（或者说抽象）到何种程度。

我们从整数的数据表示开始考虑：一个常见而有效的表示方法，就是设定几种固定的数据位数，以表示不同的范围的整数，让程序可以根据需要自行选择使用。设定的每种整数都规定了数据的读写方式（占用多少位？如何解读？），因此我们即是设定了几种不同范围的整数类型（对于负整数，计算机中往往采用补码表示，具体原因超过了本书的范围）。实数的表示也类似：我们规定几位用来表示有效数字、几位用来表示幂次，即是设定了不同范围和精度的实数类型（实际的实数表示更加复杂，需要考虑无限大、不存在等情况如何表达，参考 [IEEE 754](~https://zh.wikipedia.org/wiki/IEEE_754~) 标准）。我们观察 Rust 中的几种数值类型，来理解每种类型是如何对应不同数据表示规则的：

| 类型名 | 占用位数 | 字节数 | 数值范围 |
|:-:|:-:|:-:|:-:|
| `u8` | 8 | 1 | 0-255 |
| `u16` | 16 | 2 | 0-65535 |

类型是一种思维模型，它连接了我们的思维和计算机的具体实现：在思维层面，数据类型用来表示一类事物，是对真实事物的某种简化的模型；而在实现层面，数据类型规定了计算机如何读写一段二进制数据。和所有思维模型一样，在一定范围内，简化的模型是成立的，我们可以利用这一点更简单地思考问题；而这个成立的范围往往是由实现决定的。在编程时，我们常常需要选择范围合适的思维模型，也需要更加有意识地思考这个范围的边界：能否保证不会超出这个边界？如果超出了该怎么办呢？

对于数值类型而言，计算的结果超出类型能够表示的范围我们一般称为越界（或者叫溢出）。比如，如果两个 `u8` 类型的数相加，结果超过了 `u8` 能够表示的范围，就发生了越界。我们会看到，除了选择更大范围的类型外，越界的处理方式也有很多种。

最简单的处理方式可能是直接禁止超过范围的结果。如果超过类型能够表示的范围，程序直接报错。我们也可以把超过范围的部分忽略，这样也相当于实现了模为 256 的同余加法（比如128+128=0 (mod 256)，正好等于忽略高位的结果）。我们有时也可以认为范围内最大值表示了“最大”这个概念，这样我们可以把过大的结果用范围内能表示的最大值表示（这样 128+128 会得到 `u8` 类型所能表示的最大值 `u8::MAX`，即 255）。你可以通过如下方式在 Rust 中指定采用哪种方式：

```rust
fn main() {
    // 128u8 means number 128 with type u8
    // 128u8 + 128u8 would cause an error
    assert!(128u8.wrapping_add(128u8) == 0);
    assert!(128u8.saturating_add(128u8) == u8::MAX);
}
```

默认情况下不允许越界看似过于严格，然而，将最简单、最保守、最少假设的情况作为默认情况，能够促使我们对于自己的选择更加有意识（conscious）：每种不同的选择都会在程序中被明确表达，这些选择应当是我们知情的、有意的、主动的选择，如此我们就不会无意识间混淆例外情况和一般情况（比如将两个正数相加得到一个更小的数甚至是负数）；而如果这确实是我们的本意，程序会更加清晰地把这一意图表达出来。我们之后还会在 Rust 中看到很多类似的例子。

我们可以支持更多的数据类型用来表达更复杂的数据，但让数据真正发挥价值的不是提供更多的预先定义的数据类型，而是提供由现有类型组合形成新数据类型的方式。这种组合很接近集合运算，比如我们考虑一种最基本的组合产生新数据类型的方式：结构体（struct），新数据类型能够表达原有几种类型数据的所有可能组合。这很类似集合之间的笛卡尔积。举例而言，我们定义一个新数据类型 `Point` 如下：

```rust
struct Point(f64, f64);
```

那么 `Point` 类型所能表达的数据集合是两个 `f64` 表达集合的笛卡尔积，我们即可用它来表示二维空间中的一个点。

对于 struct 类型，Rust 中还提供了几种不同的形式供不同场合使用，但它们的本质是一致的，区别只在于是否为类型本身和类型中的元素命名：

```rust
// (f64, f64) is a anonymous tuple type
let a: (f64, f64);
// Point is a tuple struct
struct Point(f64, f64);
// NamedPoint is a struct with named fields
struct NamedPoint {
    x: f64,
    y: f64,
} 
```

我们还可以组合多个相同类型，类似集合的幂。比如我们想表示一个 \\(N\\) 维向量（对应幂集 \\(\mathbb{R}^N\\)），在 Rust 中可以写 `[f64; N]`（N 是固定的）。

这些产生新数据类型的方式，直觉上来看其实都对应着集合的乘积。也许因为这种方式更加直观、或实现上更加容易，这种方式在几乎所有语言中都有体现。然而我们将知道，这并不是唯一可行的组合方式，也不是我们唯一需要的组合方式。实际上，产生新数据类型的方法很大程度决定了一个语言**类型系统**的表达能力。我们将在第 4 章深入探讨类型系统的概念和意义，以及为什么我们需要更强大的表达能力、以及我们能用一个强大的类型系统来干什么。
