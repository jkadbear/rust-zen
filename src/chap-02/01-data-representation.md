# 数据的表达

为了能够表达一个确定的具体的事物，我们需要一段确定的、具有特定含义的二进制数据：需要一种方式明确指定这段数据，也需要在不同场合始终保持以相同的方式解读这段数据。我们一般将程序用到的具有特定含义的数据称为**数据对象**。为了指定我们需要的数据对象，我们可以为它起一个名字用来指代；而为了明确数据对象的解读方式，我们也应当为它指定一个类型。

现实的概念表达为数据，最简单也是最直观的例子是数，但这个例子中也有足够多的精细考虑，从而能够作为用数据表达概念的良好示范。

整数转换成二进制本身是容易的，你可以将转换的结果作为整数的计算机表示。在此基础上，小数也可以通过科学记数法来记录：用表示整数的方式分别记录有效数字和幂次。然而我们知道，一段数据的长度，在计算机中终究是有限的，能够表达的信息也是有限的，这意味着并不是所有的数都能在计算机中表达。于是，不管你设计怎样的数据表示方式，都是对真实概念的一种近似。数据表达概念的常见思考，就集中在考虑数据有何种需要、从而决定近似（或者说抽象）到何种程度。

我们从整数的数据表示开始考虑：一个常见而有效的表示方法，就是设定几种固定的数据位数，以表示不同的范围的整数，让程序可以根据需要自行选择使用。设定的每种整数都规定了数据的存取方式（占用多少位？如何解读？），因此我们即是设定了几种不同范围的整数类型（对于负整数，计算机中往往采用补码表示，具体原因超过了本书的范围）。实数的表示也类似：我们规定几位用来表示有效数字、几位用来表示幂次，即是设定了不同范围和精度的实数类型（实际的实数表示更加复杂，需要考虑无限大、不存在等情况如何表达，参考 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准）。我们观察 Rust 中的几种数值类型，来理解每种类型是如何对应不同数据表示规则的：

| 类型名 | 占用位数 | 字节数 | 数值范围 |
|:-:|:-:|:-:|:-:|
| `u8` | 8 | 1 | 0-255 |
| `u16` | 16 | 2 | 0-65535 |

我们需要记得，每种表示都是一种近似，对应真实概念的一种思维模型：在一定**范围**内，我们将一个概念如此表示和解读。很多时候，我们也会将类型视为所有它能表示的事物或概念的集合，来更加方便和直观地讨论它表示的范围。对数据的思考包含了对数据类型范围的思考。我们对于范围的边界应当更加谨慎，要确定类型能够表达的集合和所要解决问题的需要是匹配的。

边界的存在促使我们有意识地思考：会不会超出这个边界？如果超出了该怎么办呢？对于数值类型而言，计算的结果超出类型能够表示的范围我们一般称为越界（或者叫溢出）。比如，如果两个 `u8` 类型的数相加，结果超过了 `u8` 能够表示的范围，就发生了越界。我们会看到，越界处理方式实际上不止一种，而且几种处理方式都很合情合理。

最简单的处理方式可能是直接禁止超过范围的结果。如果超过类型能够表示的范围，程序直接报错。我们也可以把超过范围的部分忽略，这样也相当于实现了模为 256 的同余加法（比如128+128=0 (mod 256)，正好等于忽略高位的结果）。我们有时也可以认为范围内最大值表示了“最大”这个概念，这样我们可以把过大的结果用范围内能表示的最大值表示（这样 128+128 会得到 `u8` 类型所能表示的最大值 `u8::MAX`，即 255）。你可以通过如下方式在 Rust 中指定采用哪种方式：

```rust
fn main() {
    // 128u8 means number 128 with type u8
    // 128u8 + 128u8 would cause an error
    assert!(128u8.wrapping_add(128u8) == 0);
    assert!(128u8.saturating_add(128u8) == u8::MAX);
}
```

默认情况下不允许越界看似过于严格，然而，将最简单、最保守、最少假设的情况作为默认情况，能够促使我们对于自己的选择更加有意识（conscious）：每种不同的选择都会在程序中被明确表达，这些选择应当是我们知情的、有意的、主动的选择，如此我们就不会无意识间将两个正数相加得到一个更小的数甚至是负数；而如果这确实是我们的本意，程序会更加清晰地把这一意图表达出来。我们之后还会在 Rust 中看到很多类似的例子。

我们可以支持更多的数据类型用来表达更复杂的数据，但让数据真正发挥价值的不是提供更多的预先定义的数据类型，而是提供由现有类型组合形成新数据类型的方式。如果我们将类型视为它所能表达的事物的集合，那么新类型的构造，正对应了现有类型对应集合之间的集合运算。这样理解有助于我们更加全面、更加抽象地理解数据类型的组合方式。

最基本的组合产生新数据类型的方式是结构体（struct），它对应几种类型数据的所有可能组合。这类似集合之间的笛卡尔积：比如我们定义一个新数据类型 `Point` 如下：

```rust
struct Point(f64, f64);
```

那么 `Point` 类型所能表达的集合是两个 `f64` 表达集合的笛卡尔积，我们即可用它来表示二维空间中的一个点。

对于 struct 类型，Rust 中还提供了几种不同的形式供不同场合使用，但它们的本质是一致的，区别只在于是否为类型本身和类型中的元素命名：

```rust
// (f64, f64) is a anonymous tuple type
let a: (f64, f64);
// Point is a tuple struct
struct Point(f64, f64);
// NamedPoint is a struct with named fields
struct NamedPoint {
    x: f64,
    y: f64,
} 
```

我们还可以组合多个相同类型，类似集合的幂。比如我们想表示一个 \\(N\\) 维向量（对应幂集 \\(\mathbb{R}^N\\)），在 Rust 中可以写 `[f64; N]`（N 是固定的）。

这些产生新数据类型的方式，直觉上来看其实都对应着集合的乘积。也许因为这种方式更加直观、或更接近计算机的工作原理，这种方式在几乎所有语言中都有实现。然而我们将知道，这并不是唯一可行的组合方式，也不是我们唯一需要的组合方式。实际上，产生新数据类型的方法很大程度决定了一个语言**类型系统**的表达能力，我们将在第 4 章深入探讨为什么我们需要更强大的表达能力、以及我们能用一个强大的类型系统来干什么。
