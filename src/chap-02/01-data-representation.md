# 数据的表达

为了能够在计算机中表达一个确定的事物或概念，我们需要一段具有特定含义的二进制数据。我们要规定数据的读写方式，让它接近、模拟、还原我们想要表达的概念，直到我们能够在思维上认定这段数据代表了这个概念，在数据上产生的结论也能还原到真实世界中。

现实的概念表达为数据，最简单也是最直观的例子是数学上的**数**。比如，整数转换成二进制本身是容易的，因而你可以将转换的结果作为整数的计算机表示。在此基础上，小数也可以通过科学记数法来记录：用表示整数的方式分别记录有效数字和幂次。

然而我们知道，一段数据的长度，在计算机中终究是有限的，能够表达的信息也是有限的。这意味着并不是所有的数都能在计算机中被表达。可以说，不管你设计怎样的数据表示方式，它都将是对真实概念的一种近似。更普适地说，用数据表达现实概念，本质上都是一种近似或抽象，我们需要根据对数据的实际需求、来决定近似或抽象到何种程度。

我们以整数的数据表示为例：不存在一种表示方法能够表示所有的整数，因此，我们一般会设计多种表示方法，每种规定一个固定的数据位数，这样即可表达有着不同大小限制的整数，让程序根据需要自行选择使用。每种表示方式，实际上都规定了数在计算机中数据形式（也即数据的读写方式，包括占用多少位？是否支持负数？负数如何表示？参考[补码](https://zh.wikipedia.org/wiki/二補數)。）我们称这些不同的表示方式为不同的整数**类型**。实数的表示也是类似的：我们规定几位用来表示有效数字、几位用来表示幂次，即是规定了不同范围和精度的实数类型（实际的实数表示更加复杂，需要考虑无穷、不存在等情况如何表达，参考 [IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754) 标准）。在 Rust 中，语言依照这样的基本思想设置了几种原生的数值类型，我们可以从下表中更直观地看到每种类型是如何对应不同数据表示规则的：

| 类型名 | 占用位数 | 字节数 |        数值范围        |
| :----: | :------: | :----: | :--------------------: |
|  `u8`  |    8     |   1    |         0~255          |
| `u16`  |    16    |   2    |        0~65535         |
| `i32`  |    32    |   4    | -2147483648~2147483647 |
| `f32`  |    32    |   4    |          TODO          |
| `f64`  |    64    |   8    |          TODO          |

类型实际上是我们遇到的第一种思维模型。抽象来说，类型连接了我们的思维和计算机的具体实现：在思维层面，数据类型用来表示一类事物，是对真实事物的某种简化的模型；而在实现层面，数据类型规定了计算机如何读写一段二进制数据。和所有思维模型一样，在一定范围内，简化的模型是成立的，我们可以利用这一点更简单地思考问题；而这个成立的范围往往是由实现决定的。在编程时，我们常常需要选择范围合适的思维模型，也需要更加有意识地思考这个范围的边界：能否保证不会超出这个边界？如果超出了该怎么办呢？

对于数值类型和数值计算而言，计算的结果超出类型能够表示的范围，我们一般称为越界。比如，如果两个 `u8` 类型的数相加，结果超过了 `u8` 能够表示的范围，就发生了越界。正因为思维模型是一种近似，对于越界这种超过近似能够表达范围的情况，我们是需要谨慎行事的。因此，我们下面介绍几种越界的常见处理方式。

对于两个 `u8` 类型的数相加越界的情况，最简单的处理方式可能是直接禁止超过范围的结果。如果超过类型能够表示的范围，程序直接报错。这样的方案最为保守。我们也可以把结算结果超过类型范围的高位直接忽略，这个方案一般称为溢出加法。这样也相当于实现了模为 256 的同余加法（比如 128+129=1 (mod 256)，等价于忽略高位的结果），因此也叫模加法。我们有时也可以认为范围内最大值表示了“最大”这个概念，我们会把过大的结果用范围内能表示的最大值表示（这样 128+129 会得到 `u8` 类型所能表示的最大值 `u8::MAX`，即 255），这种方案称为饱和加法。在 Rust 中做计算时，你可以通过不同的语法指定使用不同的处理方案：

```rust
fn main() {
    // 直接计算 128u8 + 129u8 会报错
    assert!(128u8.wrapping_add(129u8) == 1);
    assert!(128u8.saturating_add(129u8) == u8::MAX);
}
```

> 语法解释：
>
> 1. 可以用 128u8 表示一个 u8 类型的数 128。
> 2. 除了最常规的计算和操作，其余对数据的操作大多是通过**方法**表达的（即 `.method()` 语法）。数也可以有方法，这里即通过不同名字的方法来指定不同的计算方式。
> 3. `assert!` 是一个**宏**，用来验证（或断言）表达式的成立：如果表达式不成立，这一行会报错，程序也会终止。宏的具体定义在很久之后才会提到，你现在只要把宏当作一些方便的工具来使用即可。

在加法最简单的形式中，发生越界会直接报错，这实际上意味着默认情况下，数值计算是不允许越界的。这样看似有些严格，然而却是减少程序出错的重要手段。将最简单、最保守的情况作为默认情况，能够保证我们所做的选择是经过思考的，促使我们对于自己的选择更加更加有意识（conscious）：存在多个解决方案时，程序不直接替我们解决问题，如果发生问题，程序应该直接告诉我们，让我们去选择一个需要的解决方案；而如果我们最终选择了某种解决方案，程序中应当能够把我们的选择清晰地表达出来。这样一来，每个选择都会是知情的、有意的、明确的。我们之后还会在 Rust 中看到很多类似的例子。

尽管语言可以提供更多的数据类型，但要能够表达更复杂的数据，仅仅依靠增加一些固定的数据类型是不现实的。于是，程序设计语言一般会提供由现有类型**组合**形成新数据类型的方式，开放了数据表达的可能性，让程序能够表达和处理任意的数据。直观上看，类型的组合方式很接近集合的运算，因此，我们下面通过与集合的类比来理解类型的组合。我们从结构体（struct）这一概念出发，它是一种最基本的组合产生新数据类型的方式：一个新的结构体数据类型，可以用来表达原有几种类型数据的所有可能组合。这在思想上很接近集合之间的笛卡尔积。我们带着这一类比，看一个具体的例子。在 Rust 中，我们定义一个新数据类型 `Point` 如下：

```rust
struct Point(f64, f64);
```

新定义的 `Point` 类型由两个 `f64` 类型组合而成，能够用来表示二维空间中的一个点。如果考虑每个类型能够表达的所有数据构成的集合，我们还能注意到，新类型所能表达的所有数据的集合，是两个 `f64` 能够表达的数据集合的笛卡尔积。

对于结构体类型，Rust 中还提供了几种不同的语法形式供不同场合使用，但它们的本质是一致的，区别只在于是否为类型本身和类型中的元素命名：

```rust
// (f64, f64) 是一个匿名元组（tuple）
let a: (f64, f64);
// Point 是一个元组结构体（tuple struct）
struct Point(f64, f64);
// NamedPoint 是一个常规的结构体（struct）
// 常规的结构体中，每个成员（member）都有自己的名称
struct NamedPoint { x: f64, y: f64 }
```

我们还可以组合多个相同类型，类似集合幂集的概念。比如我们想表示一个 \\(N\\) 维向量（对应幂集 \\(\mathbb{R}^N\\)），在 Rust 中可以写 `[f64; N]`（N 是固定的）。

这些产生新数据类型的方式，直觉上来看其实都对应着集合的乘积。也许因为这种方式更加直观、或实现上更加容易，这种方式在几乎所有程序设计语言中都有体现。然而我们将知道，这并不是唯一可行的组合方式，更多的组合方式也会提供更强大的表达能力。实际上，组合产生新数据类型的方式，很大程度决定了一个语言**类型系统**的表达能力。我们将在第 4 章深入探讨类型系统的概念和意义，为什么我们需要一个强大的类型系统，以及我们能用一个强大的类型系统来干什么。
