<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 编程思想</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0-0-intro.html">简介</a></li><li class="chapter-item expanded "><a href="1-0-memory.html"><strong aria-hidden="true">1.</strong> 内存管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1-1-layout.html"><strong aria-hidden="true">1.1.</strong> 数据排布</a></li><li class="chapter-item expanded "><a href="1-2-ownership.html"><strong aria-hidden="true">1.2.</strong> 所有权控制</a></li><li class="chapter-item expanded "><a href="1-3-borrowing.html"><strong aria-hidden="true">1.3.</strong> 借用：规则与打破规则</a></li><li class="chapter-item expanded "><a href="1-4-concurrency.html"><strong aria-hidden="true">1.4.</strong> 并发中的内存模型</a></li></ol></li><li class="chapter-item expanded "><a href="2-0-coding-paradigm.html"><strong aria-hidden="true">2.</strong> 编码范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-1-functional.html"><strong aria-hidden="true">2.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="2-2-enum.html"><strong aria-hidden="true">2.2.</strong> 枚举和模式匹配</a></li><li class="chapter-item expanded "><a href="2-3-zero-cost.html"><strong aria-hidden="true">2.3.</strong> 零代价抽象</a></li></ol></li><li class="chapter-item expanded "><a href="3-0-design.html"><strong aria-hidden="true">3.</strong> 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3-1-abstraction.html"><strong aria-hidden="true">3.1.</strong> 数据抽象和操作抽象：struct 和 trait</a></li><li class="chapter-item expanded "><a href="3-2-dynamic.html"><strong aria-hidden="true">3.2.</strong> 动态性：泛型和多态</a></li></ol></li><li class="chapter-item expanded "><a href="4-0-engineering.html"><strong aria-hidden="true">4.</strong> 工程组织</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-1-mods.html"><strong aria-hidden="true">4.1.</strong> 模块组织</a></li><li class="chapter-item expanded "><a href="4-2-crates.html"><strong aria-hidden="true">4.2.</strong> 包和包管理</a></li><li class="chapter-item expanded "><a href="4-3-tests.html"><strong aria-hidden="true">4.3.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="5-0-metaprogramming.html"><strong aria-hidden="true">5.</strong> 元编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5-1-simplify.html"><strong aria-hidden="true">5.1.</strong> 利用元编程简化编码</a></li><li class="chapter-item expanded "><a href="5-2-macro.html"><strong aria-hidden="true">5.2.</strong> 宏：理解和控制编译行为</a></li><li class="chapter-item expanded "><a href="5-3-cans-and-cannots.html"><strong aria-hidden="true">5.3.</strong> 元编程的能力与极限</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Rust 编程思想</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>当你理解了一门语言的思想，其语法往往是自然而然的。反过来，一门语言最有趣的也正是它的思想。虽说世上不可能有完美的语言，所有语言都要在各种矛盾中权衡而做不到万全，但这不妨碍 rust 有几处思想颇有见地。而其中最广泛存在和影响这门语言的，可能是如下两条：</p>
<p>第一，rust 鼓励甚至强制实现<strong>明确化</strong>（explicitness），即让使用者对他在做的事完全了解和掌控。当今绝大多数语言似乎都营造了一个假象，即你不需要了解一切、不需要熟悉计算机工作原理、不需要熟悉编译机制，也可以编程。这种假象，或者由于语言限制很多、或者由于语言限制太少，这两种截然不同的理由。前者的一个例子是垃圾回收：垃圾回收对于内存管理是有诸多限制的，比如程序员并不能自己决定内存释放的时间，而这使得程序员不需要了解内存的工作机制也能编程，这很多时候是个好的假象，但是也是个很强的限制；而后者的例子是指针，程序员可以使用指针对内存直接操作，指针也可以任意运算，而只要结果正确，很多细节往往容易得过且过，这种假象不一定是语言想要的结果，也未必是好事了。</p>
<blockquote>
<p>With great power comes great responsibility.</p>
<p>— <code>sudo</code> lecture</p>
</blockquote>
<p>实际上，对计算机越多控制，越需要对计算机深入理解，这从本质上就是绕不开的，而 rust 认识到了这一点。Rust 作为系统编程语言，没有试图遮遮掩掩，而是将所有底层细节在语言层面，较以前更为提前、更为明确地暴露出来。举例而言，C 和 C++ 中，一个 struct 的主要数据存储在栈还是堆上，是不能很显然看出来的，本质上也是因为指针就没有对应的区分；但 rust 中栈和堆上的“指针”是有不同的语法语义的，在更高的 struct 层次，数据存储位置也可以很明显地通过 Copy trait 区分。类似这些也导致了 rust 的一个广为人知的特点：很难通过编译，学习成本极高。但这并不是 rust 的劣势，rust 其实并没有平添复杂性，而是把本来的复杂性尽可能早地真实完整地暴露给使用者而已。一方面它打碎了一些不切实际的假象，而另一方面，一旦你写出可以通过编译的 rust 程序，你会对程序拥有前所未有的信心，因为语言虽不能保证你万无一失，但在努力保证你完全清楚你在做的事情。</p>
<p>第二，rust 在不失明确的前提下，利用尽可能强大的<strong>抽象</strong>（abstraction），让使用者不至于迷失在细节当中。抽象而不失细节的最好例子可能是数学，也正是得益于其明确性。对比更加数学化的语言（如 Haskell），rust 借鉴了其中大量抽象思想，但除了对数学化抽象本身的明确性、又增加了对系统的明确性，使得 rust 很好地将高层抽象和底层细节合并起来。这让 rust 作为一个系统级语言，表达力也能够毫不落伍。</p>
<p>值得一提的是，rust 在数学性的抽象（函数等）、和为了让功能使用变得更加容易而存在的语言特征（宏）之间，有较为明显的区分，这也是之前不曾有的。甚至在你的第一个“你好，世界”程序里，rust 也会通过 <code>!</code> 明确告诉你，<code>println!</code> 不是个单纯的（数学性的）函数，而只是一组程序的简洁写法。我们可以认为宏是语言词法层次的抽象：可将一套无法用前述抽象机制实现、但形式上多有繁复的代码片段，抽象为一个新的词法；或者通俗而言，可以就理解为操作代码本身的代码（即所谓元编程）。这样的区分，使得 rust 能维持精简而专注的抽象内核，同时仍然能提供大量实际便利；另一方面，明确这种区分，也如前文所说，能够不失精细控制、提升对程序的认识和信心。</p>
<p>可以说，这两条是 rust 能作为系统语言存在的前提和优势所在。Rust 程序员第一本教科书（<a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a>）特意提到 rust 的核心价值是<strong>赋能</strong>（empowerment），也正是从这两点中体现：rust 程序员从明确中获得更多信心，从高度抽象中获得处理更复杂事务的能力和更广阔的可能性。当然 rust 远不止于此，诸多设计选择、实现细节、还有很多来自当前时代其他语言的最佳实践中，也都蕴含了许多思想。这些或零或整、或明或暗的思想，这些思想对语言的影响，以及这些思想对于编译器实现会有哪些新的需求，正是本书的主题。虽不敢说完整通透，也至少能管中窥豹、可见一斑。</p>
<p>由于本书的目的是在思想和思维方式的层面讨论 rust，所有的语言细节均是用来体现思想的例子，因此这本书绝不能算是 rust 或系统编程的入门教程，对 rust 的介绍也并不全面和系统。基于此，这本书并不是很适合初学计算机或编程语言的人阅读。第一次接触一个事物，最重要的还是要保持兴趣，尝试做以前做不到的事。思考、总结、优化往往是后话。</p>
<blockquote>
<p>Premature optimization is the root of all evil. （过早优化是万恶之源。）</p>
<p>— Donald Knuth</p>
</blockquote>
<p>Rust 至今仍算是个正在快速发展的语言，谁也无法做到完整掌握，更无法预测未来。这一点对很多其他语言也是成立的。作为程序员该如何思考编程本身、如何发展完善自己的思考方式和思维过程，或许比理解一门特定的语言更为重要，因为这些是不会过时的。这就好比摄影师更需要理解光线和构图，而不是相机的操作细节。这也是写作本书的最大动机了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h1>
<blockquote>
<p>程序 = 算法 + 数据结构 （或者更简单的版本：<strong>程序 = 过程 + 数据</strong>）</p>
</blockquote>
<p>如今，用很多编程语言（如 Python）写程序，很多时候我们并不需要关心我们所操作的数据在哪里，还在不在那。这些语言不仅保证在你还需要一份数据的时候，它能够随时被访问到，很多时候它们还做一些更为隐蔽的内存操作，让你不必考虑它们在内存中的何处、为它们最初的分配空间是否足够、多余的空间是否浪费，等等。</p>
<p>这些自动化的内存管理都无可争议地大大简化了编程的思维方式。但如同计算机科学中的每一个话题，在获得一项好处的同时，必然意味着对另一些的舍弃。很多时候这种取舍确实是值得的（这就是为什么 Python、Java 等语言总是在最受欢迎的语言列表中），但它并不是所有情况下的最佳选项。在讨论另一种的解决方案之前，我们首先了解一下大多数编程语言为了更简单的内存管理，都舍弃了些什么。</p>
<p>首先，为了提供一个更加简单的数据访问模型，一些额外的性能损失是无法避免的。这些损失包括维持访问模型的直接开销，如在 Java 中，程序不需要关心数据所占用的内存空间何时分配、何时释放，但 JVM 需要通过额外的垃圾回收机制保证数据的分配和释放；也包括无法实现最优的内存排布所导致的间接损失，这种损失既可能来自于程序员不了解内存排布对性能的影响而无意编写出的低效程序，也可能最优的方案由于语言限制根本就无法实现。如果应用本身对于性能并不敏感，这些损失我们可以不必在意，而不断发展的编译器优化技术也在缓解这两类性能损失。然而，在性能高度敏感的基础性应用中，这些额外损耗就变得不那么能接受了。</p>
<p>除了执行性能的损失外，为了提供简化的数据访问模型，语言的运行时（Runtime）也会变得更加庞大。每个程序语言的运行时需要构建起程序的抽象模型到实际机器的桥梁，程序抽象越远离机器，这座桥梁就需要越大。在有些语言中，这座桥梁所要承载的功能太过复杂，以至于语言提供了专门的解释器/虚拟机层来实现。这些语言的运行时往往十分庞大（如 Node.js 运行时超过 30MB，Java 运行时超过 100MB）。另一些语言（即编译型语言，如 C、C++、Go 等）通过实现运行时库函数（runtime library）来构建这类桥梁，更简化的模型也将不可避免地带来更大的库函数。同样，这个问题很多时候都不算是问题，但在系统编程中，即使这样的问题也值得锱铢必较。</p>
<p>【失去底层控制】</p>
<p>读到这里，也许你想：“这些问题我都不是很在意，这本书我不必看了。”你也许对于很多语言提供的抽象比较满意，也愿意付出一些代价。但这种模式还存在一个问题：往往你要付出的代价是隐性的、强制的。这有点像你去办电信业务，你总会想知道你的套餐包含哪些服务、分别要多少费用，你还应当能够随时退订你不需要的服务、从而不再为它们付钱。但不同语言提供的“服务”更像是一种不能更改的套餐，你也不能明确知道你在为什么付出代价。一旦将来有一天你觉得当前的代价过高，你很难知道到底是什么服务导致的，很多时候你甚至根本无法退订这些服务。</p>
<p>总结而言，当前的编程语言为了提供更简单的内存管理，削弱了程序的效率和控制力，也影响了你选择的权利，而这些都成为了 C / C++ 等底层系统语言仍然存在的关键理由。</p>
<p>习惯了高级程序语言的程序员，可能会觉得 C 语言的内存管理充满了陷阱。其中的原因也很好理解：真实的机器其实并不如抽象模型中的那样简洁，而 C 语言作为更加接近机器的底层语言，既不会替你考虑、也不会为你掩盖这些细枝末节。【问题：容易出错】</p>
<p>C++ 通过为 C 语言增添不同的编程范式，似乎为这一问题提供了一个解决思路：提供给程序员更多的工具，程序员就可以通过很多手段从细枝末节中脱离出来。这里似乎蕴含了一个假定：程序越容易编写，就越不容易出错，然而这个假定本身也有些偏颇。【1. 细节和复杂性终究存在，“容易”到底是处理了复杂性还是在掩盖复杂性？2. 使用工具的终究是人，更多的工具会不会成为更多错误的源泉？】</p>
<p>错误的真正来源是人对于复杂性难以处理。掩盖复杂性并不可取，把复杂性更加直接、更加明确地呈现出来似乎才是正确的道路。而真正处理复杂性的手段，在计算机科学的历史中也无数次被证明，不是期待人去解决更复杂的问题，而是依靠抽象的手段、让人能够解决更简单问题。</p>
<p>下面我们就从明确复杂性出发，看看 Rust 是如何将内存管理的细节通过语言本身呈现出来的。</p>
<!-- 
程序员常常会问自己这样一个问题，如何提高我的程序的性能？有个有点偷懒但很有效的答案，就是寻找程序当前的**性能瓶颈**并优化它。那么更具体一点说，性能瓶颈一般在哪呢？第一有可能的瓶颈自然是算法，但第二可能便是内存控制了。

> 程序 = 算法 + 数据结构 （或者更简单的版本：**程序 = 过程 + 数据**）

对于程序而言，内存是操作系统提供的一种即时的、高效的数据存储的抽象，然而这种高效不是完美的：内存的访问速度终究有限，内存本身也并非无穷大，内存的分配、释放、移动等都需要一定的管理成本。为了应对这些问题，硬件和操作系统实现了多级缓存等机制，能够在很多情况下直接带来隐式的效率提升，但这仍不意味着程序可以以任意的方式使用内存。对于程序而言，若能够了解和规避内存的局限性、充分运用缓存等底层机制，仔细地规划内存的使用，程序的性能常常能够得到更深度的优化。

除了宽泛的性能问题之外，程序员希望对内存有更精细的控制的场合还有很多，比如对确定性或实时性有较高要求的场合，系统资源高度受限的场合，针对操作系统底层进行开发的场合等。但长久以来，系统程序员似乎面临着这样的困境：在现有的语言中，选择了更多更底层的控制，就意味着更容易出错；而选择了安全保障，则意味着更少控制。类似的抉择常常在是否要垃圾回收上体现：选择垃圾回收，你可以获得对内存访问的更多保障，如没有内存泄露问题，也没有悬垂指针、二次释放等广泛存在的内存安全问题，但你也因此无法直接触碰内存、控制内存的排布，无法决定（或者难以决定）何时回收垃圾，从而失去了一些优化的可能（编译器或虚拟机有时会帮你优化，你也可以通过编码技巧来促进这种优化，但终究比较间接和不可控）。

那么，底层控制和安全性真的无法同时保障吗？需要首先明确的是，越接近底层控制，程序员越需要对底层机制有深入的了解，面对的状况也越复杂，这个复杂性是无法规避的。但复杂性并不直接意味着失去安全性，仅仅是提供安全保障也不意味着必须削弱控制。也就是说底层控制和安全保障并不是直接冲突的。我们真正需要解决的是复杂性的问题。

泛泛而言，复杂性导致出错不外乎如下几个原因：

* 对复杂性理解不足；
* 繁琐的细节中出错；
* 疲于应付繁琐细节、导致整体逻辑出错。

解决问题也应该是对症下药，通过明确化来直面复杂性，和通过抽象来解决复杂性。

**直面复杂性**：复杂性越直接暴露，也就越能促使程序员深入了解背后发生了什么。系统编程最为复杂的部分便是内存控制。因而，本章节将介绍内存机制如何在 rust 中显式呈现、不同的内存操作对操作对象有何要求、以及 rust 所提供的不同层次的安全保障和所要付出代价之间的显式权衡，最后以并发编程为例，展示这种明确化的潜在力量。

**应对复杂性**：几乎每一本计算机科学的书都会谈到，应对复杂性最佳方式是抽象，而 rust 的抽象机制将在后续章节中介绍。 -->
<!--
参考：
https://doc.rust-lang.org/nomicon/index.html
https://docs.rust-embedded.org/book/static-guarantees/index.html
https://doc.rust-lang.org/1.5.0/book/choosing-your-guarantees.html
-->
<div style="break-before: page; page-break-before: always;"></div><h2 id="数据排布"><a class="header" href="#数据排布">数据排布</a></h2>
<p>如前所述，你有时会需要对内存的精细控制，为此，首先你需要理解在内存中数据是如何排布的。</p>
<h3 id="数据和数据类型"><a class="header" href="#数据和数据类型">数据和数据类型</a></h3>
<p>内存线性模型。</p>
<p>数据本身及数据类型。</p>
<p>数据计算，overflow 的处理。</p>
<h3 id="数据的放置与操作"><a class="header" href="#数据的放置与操作">数据的放置与操作</a></h3>
<p>如前所述，在操作系统的抽象下，我们可以认为，数据对象存在于一块线性的内存中。然而这些数据对象具体放置在什么地方呢？考虑到程序运行机制，程序运行时所操作的数据，要么跟随函数调用在栈上存取，要么自由存放在堆中。栈空间中的数据，根据函数调用和返回、空间会被自动分配和放回；而堆上的数据可以脱离函数调用关系独立地存在，分配和放回需要主动执行相应的操作。如此，我们首先从程序运行机制说起，具体观察一下函数调用栈、以及 Rust 中如何表达栈上的数据及操作。</p>
<!-- 例子，图示，剖析，再接总结 -->
<p>函数内的数据可根据函数调用关系自然地组成栈结构：函数调用时数据入栈，函数退出时数据出栈。更具体而言，函数调用时，将函数的参数首先入栈（填充数据并移动栈顶指针），然后预留一段空间（仅移动指针不填充数据）供函数存放数据，这时函数可以进一步调用其他函数（继续入栈），或执行操作后返回，将自身的数据、参数等出栈，将返回值置于栈顶。</p>
<p>数据以一个十分规整的方式组织，每个函数可以<strong>静态</strong>地得知自身数据的位置，因而可以直接访问（即不需要通过查找地址访问）。另外，这种规整性也对数据排布带来更高的要求：函数预留的数据大小必须<strong>静态</strong>地确知、不能改变。</p>
<p>Rust 中通过数据类型来静态地确定函数预留空间的大小。如下面的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
fn main() {
    let a: i32 = 0;
    println!(&quot;{}&quot;, mem::size_of_val(&amp;a));  // -&gt; 4
}
</code></pre></pre>
<p>编译器可以通过统计函数中有哪些变量、每个变量对应的类型所占空间大小，在编译期静态地确定一个函数需要多大的栈空间。你也注意到，Rust 的基础数值类型从名字上就能确定占用空间（比如 <code>i32</code> 类型占用 32 比特位）。</p>
<p>由基础数据类型组成的复合类型也是必不可少的。其中大小比较容易确定的是数组（array，固定大小的、单一类型的顺序容器）、元组（tuple，定长、异构的顺序容器）和结构体（struct，多种类型复合的数据结构）。需要额外讨论的是枚举类型（enum）。枚举类型为什么存在会在后面讲述，只要注意到枚举类型的变量必须是几个变种中的一个，因此实际数据需要的空间设置为最大的那个变种需要的空间大小即可，另外还需要一些空间来存储具体是哪个变种。在一些场合，是哪个变种可以通过数值确定，因而这部分额外空间也可以不要。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct Point { x: f64, y: f64 }

fn main() {
    println!(&quot;{}&quot;, mem::size_of::&lt;i32&gt;());              // -&gt; 4
    println!(&quot;{}&quot;, mem::size_of::&lt;[i32; 10]&gt;());        // -&gt; 40
    println!(&quot;{}&quot;, mem::size_of::&lt;Point&gt;());            // -&gt; 16
    println!(&quot;{}&quot;, mem::size_of::&lt;Result&lt;i32, f64&gt;&gt;()); // -&gt; 16
    println!(&quot;{}&quot;, mem::size_of::&lt;Option&lt;&amp;i32&gt;&gt;());     // -&gt; 8 (pointer size); notice null pointer optimization
}
</code></pre></pre>
<p>所有这些大小可静态获知的类型，均可以直接放置在栈上，也就可以在函数中作为局部变量、函数参数和返回值使用。值得一提的是，Rust 还进一步从语言层面明确了哪些类型是大小可静态获知的：每个这样的类型都实现了 <code>Sized</code> trait。那些大小不可知的类型，并不是为了保存数据而存在的，关于它们的作用我们暂且不提。</p>
<p>总结而言，Rust 通过变量表示一段栈空间，通过变量的类型明确了变量的存储方式。下一步是对变量的操作。对局部变量（即栈上的一段空间）的操作，在很多语言中都笼统地用赋值指代了。然而各种赋值中实际发生的事其实并不那么单纯。考虑 C 语言中的下面几种情况：</p>
<pre><code class="language-c">int a, b, c;
a = 3;
b = a;
c = some_func_returning_int(b);
</code></pre>
<ol>
<li>初始化</li>
<li>拷贝内容</li>
<li>传递参数，接收返回，“移动”而不是拷贝</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy, Clone)]
struct Point { x: f64, y: f64 }

fn main() {
    let mut a = Point { x: 3.0, y: 4.0 };
    let b = a;
    a.x = 5.0;
    println!(&quot;{}&quot;, a.x);  // -&gt; 5.0
    println!(&quot;{}&quot;, b.x);  // -&gt; 3.0
}
</code></pre></pre>
<!--
* 如前所述，你有时会需要对内存的精细控制。特别的，你需要理解内存中的数据排布
* 栈和堆：数据可能存在寄存器、缓存、内存、硬盘等任何地方，但程序执行时，操作系统对于数据提供了一层抽象：程序所操作的数据，要么跟随函数调用在栈上存取，要么自由存放在堆中。
* 栈上数据、堆上数据的不同：前者跟随函数调用、自动分配和放回、大小编译时确知，数据地址生命周期跟随函数生命周期；后者脱离函数调用、需要要自行分配和放回，数据地址存在悬垂指针、二次释放等问题。
* 详细分析栈：本质上是函数调用栈，栈上的数值（变量和变量类型，明确区分），地址（表示地址的类型系统），栈上的赋值（拷贝），函数返回，地址的生命周期概念。
* 静态数据：整个程序生命周期都存在
* 引入堆：为什么需要堆（https://stackoverflow.com/a/10483164），堆上数据和地址的不同：需要分配和释放，为什么及如何明确栈和堆的区别，实现跟随调用栈的生命周期
* 一些问题：赋值的复杂性、拷贝导致的问题、函数返回导致的问题、rc/gc的代价，引出下一节所有权机制和移动的概念
-->
<div style="break-before: page; page-break-before: always;"></div><h2 id="所有权控制"><a class="header" href="#所有权控制">所有权控制</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="借用规则与打破规则"><a class="header" href="#借用规则与打破规则">借用：规则与打破规则</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="并发中的内存模型"><a class="header" href="#并发中的内存模型">并发中的内存模型</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编码范式"><a class="header" href="#编码范式">编码范式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="函数式编程"><a class="header" href="#函数式编程">函数式编程</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="枚举和模式匹配"><a class="header" href="#枚举和模式匹配">枚举和模式匹配</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="零代价抽象"><a class="header" href="#零代价抽象">零代价抽象</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计抽象"><a class="header" href="#设计抽象">设计抽象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="数据抽象和操作抽象struct-和-trait"><a class="header" href="#数据抽象和操作抽象struct-和-trait">数据抽象和操作抽象：<code>struct</code> 和 <code>trait</code></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="动态性泛型和多态"><a class="header" href="#动态性泛型和多态">动态性：泛型和多态</a></h2>
<p>http://www.cs.ox.ac.uk/jeremy.gibbons/publications/dgp.pdf</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工程组织"><a class="header" href="#工程组织">工程组织</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="模块组织"><a class="header" href="#模块组织">模块组织</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="包和包管理"><a class="header" href="#包和包管理">包和包管理</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元编程"><a class="header" href="#元编程">元编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="利用元编程简化编码"><a class="header" href="#利用元编程简化编码">利用元编程简化编码</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h2 id="宏理解和控制编译行为"><a class="header" href="#宏理解和控制编译行为">宏：理解和控制编译行为</a></h2>
<!-- 
参考：
https://doc.rust-lang.org/reference/macros.html
https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html
https://github.com/dtolnay/proc-macro-workshop
https://doc.rust-lang.org/edition-guide/introduction.html
-->
<div style="break-before: page; page-break-before: always;"></div><h2 id="元编程的能力与极限"><a class="header" href="#元编程的能力与极限">元编程的能力与极限</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
