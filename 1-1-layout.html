<!DOCTYPE HTML>
<html lang="zh-cn" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据排布 - Rust 编程思想</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="0-0-intro.html">简介</a></li><li class="chapter-item expanded "><a href="1-0-memory.html"><strong aria-hidden="true">1.</strong> 内存控制</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1-1-layout.html" class="active"><strong aria-hidden="true">1.1.</strong> 数据排布</a></li><li class="chapter-item expanded "><a href="1-2-ownership.html"><strong aria-hidden="true">1.2.</strong> 所有权控制</a></li><li class="chapter-item expanded "><a href="1-3-borrowing.html"><strong aria-hidden="true">1.3.</strong> 借用：规则与打破规则</a></li><li class="chapter-item expanded "><a href="1-4-concurrency.html"><strong aria-hidden="true">1.4.</strong> 并发中的内存模型</a></li></ol></li><li class="chapter-item expanded "><a href="2-0-coding-paradigm.html"><strong aria-hidden="true">2.</strong> 编码范式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="2-1-functional.html"><strong aria-hidden="true">2.1.</strong> 函数式编程</a></li><li class="chapter-item expanded "><a href="2-2-enum.html"><strong aria-hidden="true">2.2.</strong> 枚举和模式匹配</a></li><li class="chapter-item expanded "><a href="2-3-zero-cost.html"><strong aria-hidden="true">2.3.</strong> 零代价抽象</a></li></ol></li><li class="chapter-item expanded "><a href="3-0-design.html"><strong aria-hidden="true">3.</strong> 设计抽象</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3-1-abstraction.html"><strong aria-hidden="true">3.1.</strong> 数据抽象和操作抽象：struct 和 trait</a></li><li class="chapter-item expanded "><a href="3-2-dynamic.html"><strong aria-hidden="true">3.2.</strong> 动态性：泛型和多态</a></li></ol></li><li class="chapter-item expanded "><a href="4-0-engineering.html"><strong aria-hidden="true">4.</strong> 工程组织</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-1-mods.html"><strong aria-hidden="true">4.1.</strong> 模块组织</a></li><li class="chapter-item expanded "><a href="4-2-crates.html"><strong aria-hidden="true">4.2.</strong> 包和包管理</a></li><li class="chapter-item expanded "><a href="4-3-tests.html"><strong aria-hidden="true">4.3.</strong> 测试</a></li></ol></li><li class="chapter-item expanded "><a href="5-0-metaprogramming.html"><strong aria-hidden="true">5.</strong> 元编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5-1-simplify.html"><strong aria-hidden="true">5.1.</strong> 利用元编程简化编码</a></li><li class="chapter-item expanded "><a href="5-2-macro.html"><strong aria-hidden="true">5.2.</strong> 宏：理解和控制编译行为</a></li><li class="chapter-item expanded "><a href="5-3-cans-and-cannots.html"><strong aria-hidden="true">5.3.</strong> 元编程的能力与极限</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 编程思想</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#数据排布" id="数据排布">数据排布</a></h2>
<p>如前所述，你有时会需要对内存的精细控制，为此，首先你需要理解在内存中数据是如何排布的。</p>
<h3><a class="header" href="#数据和数据类型" id="数据和数据类型">数据和数据类型</a></h3>
<p>内存线性模型。</p>
<p>数据本身及数据类型。</p>
<p>数据计算，overflow 的处理。</p>
<h3><a class="header" href="#数据的放置与操作" id="数据的放置与操作">数据的放置与操作</a></h3>
<p>数据可能存在于寄存器、缓存、内存、硬盘等任何地方，但程序执行时，操作系统对于程序运行时所需要访问的数据提供了一层抽象：程序所操作的数据，要么跟随函数调用在栈上存取，要么自由存放在堆中。栈空间中的数据，根据函数调用和返回、空间会被自动分配和放回；而堆上的数据可以脱离函数调用关系独立地存在，分配和放回需要主动执行相应的操作。我们首先具体观察一下函数调用栈，以及 Rust 中如何表达栈上的数据及操作。</p>
<!-- 例子，图示，剖析，再接总结 -->
<p>函数内的数据可根据函数调用关系自然地组成栈结构：函数调用时数据入栈，函数退出时数据出栈。更具体而言，函数调用时，将函数的参数首先入栈（填充数据并移动栈顶指针），然后预留一段空间（仅移动指针不填充数据）供函数存放数据，这时函数可以进一步调用其他函数（继续入栈），或执行操作后返回，将自身的数据、参数等出栈，将返回值置于栈顶。</p>
<p>数据以一个十分规整的方式组织，每个函数可以<strong>静态</strong>地得知自身数据的位置，因而可以直接访问（即不需要通过查找地址访问）。另外，这种规整性也对数据排布带来更高的要求：函数预留的数据大小必须<strong>静态</strong>地确知、不能改变。</p>
<p>Rust 中通过数据类型来静态地确定函数预留空间的大小。如下面的例子：</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;
fn main() {
    let a: i32 = 0;
    println!(&quot;{}&quot;, mem::size_of_val(&amp;a));  // -&gt; 4
}
</code></pre></pre>
<p>编译器可以通过统计函数中有哪些变量、每个变量对应的类型所占空间大小，在编译期静态地确定一个函数需要多大的栈空间。你也注意到，Rust 的基础数值类型从名字上就能确定占用空间（比如 <code>i32</code> 类型占用 32 比特位）。</p>
<p>由基础数据类型组成的复合类型也是必不可少的。其中大小比较容易确定的是数组（array，固定大小的、单一类型的顺序容器）、元组（tuple，定长、异构的顺序容器）和结构体（struct，多种类型复合的数据结构）。需要额外讨论的是枚举类型（enum）。枚举类型为什么存在会在后面讲述，只要注意到枚举类型的变量必须是几个变种中的一个，因此实际数据需要的空间设置为最大的那个变种需要的空间大小即可，另外还需要一些空间来存储具体是哪个变种。在一些场合，是哪个变种可以通过数值确定，因而这部分额外空间也可以不要。</p>
<pre><pre class="playground"><code class="language-rust">use std::mem;

struct Point { x: f64, y: f64 }

fn main() {
    println!(&quot;{}&quot;, mem::size_of::&lt;i32&gt;());              // -&gt; 4
    println!(&quot;{}&quot;, mem::size_of::&lt;[i32; 10]&gt;());        // -&gt; 40
    println!(&quot;{}&quot;, mem::size_of::&lt;Point&gt;());            // -&gt; 16
    println!(&quot;{}&quot;, mem::size_of::&lt;Result&lt;i32, f64&gt;&gt;()); // -&gt; 16
    println!(&quot;{}&quot;, mem::size_of::&lt;Option&lt;&amp;i32&gt;&gt;());     // -&gt; 8 (pointer size); notice null pointer optimization
}
</code></pre></pre>
<p>所有这些大小可静态获知的类型，均可以直接放置在栈上，也就可以在函数中作为局部变量、函数参数和返回值使用。值得一提的是，Rust 还进一步从语言层面明确了哪些类型是大小可静态获知的：每个这样的类型都实现了 <code>Sized</code> trait。那些大小不可知的类型，并不是为了保存数据而存在的，关于它们的作用我们暂且不提。</p>
<p>总结而言，Rust 通过变量表示一段栈空间，通过变量的类型明确了变量的存储方式。下一步是对变量的操作。对局部变量（即栈上的一段空间）的操作，在很多语言中都笼统地用赋值指代了。然而各种赋值中实际发生的事其实并不那么单纯。考虑 C 语言中的下面几种情况：</p>
<pre><code class="language-c">int a, b, c;
a = 3;
b = a;
c = some_func_returning_int(b);
</code></pre>
<ol>
<li>初始化</li>
<li>拷贝内容</li>
<li>传递参数，接收返回，“移动”而不是拷贝</li>
</ol>
<pre><pre class="playground"><code class="language-rust">#[derive(Copy, Clone)]
struct Point { x: f64, y: f64 }

fn main() {
    let mut a = Point { x: 3.0, y: 4.0 };
    let b = a;
    a.x = 5.0;
    println!(&quot;{}&quot;, a.x);  // -&gt; 5.0
    println!(&quot;{}&quot;, b.x);  // -&gt; 3.0
}
</code></pre></pre>
<!--
* 如前所述，你有时会需要对内存的精细控制。特别的，你需要理解内存中的数据排布
* 栈和堆：数据可能存在寄存器、缓存、内存、硬盘等任何地方，但程序执行时，操作系统对于数据提供了一层抽象：程序所操作的数据，要么跟随函数调用在栈上存取，要么自由存放在堆中。
* 栈上数据、堆上数据的不同：前者跟随函数调用、自动分配和放回、大小编译时确知，数据地址生命周期跟随函数生命周期；后者脱离函数调用、需要要自行分配和放回，数据地址存在悬垂指针、二次释放等问题。
* 详细分析栈：本质上是函数调用栈，栈上的数值（变量和变量类型，明确区分），地址（表示地址的类型系统），栈上的赋值（拷贝），函数返回，地址的生命周期概念。
* 静态数据：整个程序生命周期都存在
* 引入堆：为什么需要堆（https://stackoverflow.com/a/10483164），堆上数据和地址的不同：需要分配和释放，为什么及如何明确栈和堆的区别，实现跟随调用栈的生命周期
* 一些问题：赋值的复杂性、拷贝导致的问题、函数返回导致的问题、rc/gc的代价，引出下一节所有权机制和移动的概念
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="1-0-memory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="1-2-ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="1-0-memory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="1-2-ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
